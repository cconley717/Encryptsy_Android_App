# Encryptsy_Android_App

Encryptsy is an Android app that provides encryption functionality via the AES algorithm in the GCM mode. In making this app, I wanted to create a solution that was easy to use and designed around the use of just two buttons: encrypt and decrypt. I also wanted to create a solution that was, although simple to use, was powerful in the security that it provided.

Most encryption apps ask the user to set a global encryption key through the use of a passphrase, which I felt to be a central point of failure and a serious vulnerability. When one takes passwords into account, users generally use one that they're already familiar with, or is at least easy to remember. Brute force techniques can crack such passwords in seconds. Therefore, I wanted to create an encryption service that did not rely on user input for the encryption/decryption process to take place, beyond logging into their account.

When the user creates an account, a "vault" file is generated on their device for that account. The vault will hold the 256-bit encryption keys and 128-bit initialization vectors for each encrypted file that is encrypted under that account. The vault is encrypted with a vault encryption key (VEK), and the VEK is encrypted with a vault companion key (VCK). The VCK is then encrypted with the encrypted VEK. The encrypted VCK stays with the vault on the device, and the encrypted VEK is sent to the Encryptsy server along with the username, password, and decoy password. The username, password, and decoy password are BCrypt hashed, then stored within a database. If the user signs in with their decoy password, it will delete the account from the Encryptsy database. This is useful in the event that the user is under duress in releasing their login credentials. Upon logging into their account, the encrypted VEK is retrieved from the server and will be used to decrypt the encrypted VCK on the user's device. The decrypted VCK is then used to decrypt the VEK. Now that the VEK is decrypted, it will then be used to decrypt the vault. The decrypted vault will then be held in memory. Everytime the vault is updated, it is re-encrypted and re-written to the filesystem.

This design ensures that the single point of failure is the user and the strength of their login credentials. Without their login credentials, the best course of action would be to brute force that account's vault file on the user's device since each encrypted file's securely generated keys and initialization vectors reside within it. Accounts are tied to the device in which they were created on, so this would involve procuring the user's device.
